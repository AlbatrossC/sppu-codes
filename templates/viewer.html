<!doctypehtml><html lang=en><meta charset=UTF-8><meta content="width=device-width,initial-scale=1"name=viewport><meta content="IE=edge"http-equiv=X-UA-Compatible><meta content="SPPU Codes Question Viewer - Fast and efficient PDF viewer for exam papers"name=description><link href="{{ url_for('get_image', filename='favicon.ico') }}"rel=icon fetchpriority=high type=image/x-icon><title>SPPU ${subjectName} Question Papers</title><script defer src=/static/js/tutorial.js></script><link href=/static/pdfjs/web/viewer.html rel=preload fetchpriority=high as=document><link href=/static/pdfjs/web/viewer.css rel=preload fetchpriority=high as=style><link href=static/css/viewer.css rel=stylesheet><link href=/static/pdfjs/web/viewer.js rel=preload fetchpriority=high as=script><link href=/static/pdfjs/web/pdf.js rel=preload fetchpriority=high as=script><link href=/static/pdfjs/web/pdf.worker.js rel=preload fetchpriority=high as=worker><header><div class=header-info><button class=back id=back-btn><svg class=icon fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg> Back</button><div class=subject-badge id=subject-display>Loading Subject...</div></div><div class=header-center><div class=control-group><label for=pdf-count>PDF Layout:</label> <select id=pdf-count><option value=1>Single View<option value=2>Split View (2)<option value=3>Split View (3)<option value=4>Grid View (4)</select></div><div class=control-group><label for=exam-type>Exam Type:</label> <select id=exam-type><option value=insem>INSEM<option value=endsem>ENDSEM</select></div></div><div class=header-controls><button class=primary id=fullscreen-btn><svg class=icon fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg> Fullscreen</button></div></header><div class=grid-1 id=pdf-container><div class=no-pdf-message>Loading PDFs...<div class=loader></div></div></div><script>'use strict';
    const DOM = {
        pdfContainer: document.getElementById('pdf-container'),
        subjectDisplay: document.getElementById('subject-display'),
        pdfCount: document.getElementById('pdf-count'),
        examType: document.getElementById('exam-type'),
        fullscreenBtn: document.getElementById('fullscreen-btn'),
        backBtn: document.getElementById('back-btn')
    };

    const state = {
        pdfPath: new URLSearchParams(window.location.search).get('pdf'),
        pdfFiles: [],
        isRendering: false,
        listCache: new Map(), 
        pdfContentCache: new Map(),
        activeObjectURLs: new Map(),
        renderQueue: Promise.resolve(),
        pdfViewerBase: '/static/pdfjs/web/viewer.html',
        cacheVersion: 'v1.1', 
        prefetchQueue: [],
        maxCacheSize: 50, 
        cacheExpiry: 7 * 24 * 60 * 60 * 1000,
        db: null
    };

    const initDB = () => {
        return new Promise((resolve) => {
            if (!('indexedDB' in window)) {
                console.warn('IndexedDB not supported, falling back to memory cache.');
                resolve(null); return;
            }
            const request = indexedDB.open('SPPUPDFCache', 2);
            request.onerror = (event) => { console.error('IndexedDB error:', event.target.error); resolve(null); };
            request.onsuccess = (event) => {
                state.db = event.target.result;
                cleanupExpiredCache();
                resolve(state.db);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('pdfFiles')) {
                    const store = db.createObjectStore('pdfFiles', { keyPath: 'url' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
                if (!db.objectStoreNames.contains('pdfLists')) {
                    const store = db.createObjectStore('pdfLists', { keyPath: 'path' });
                    store.createIndex('timestamp', 'timestamp', { unique: false });
                }
            };
        });
    };

    const cleanupExpiredCache = async () => {
        if (!state.db) return;
        const storesToClean = ['pdfFiles', 'pdfLists'];
        const cutoff = Date.now() - state.cacheExpiry;

        for (const storeName of storesToClean) {
            try {
                const transaction = state.db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const index = store.index('timestamp');
                const request = index.openCursor(IDBKeyRange.upperBound(cutoff));
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        store.delete(cursor.primaryKey);
                        cursor.continue();
                    }
                };
            } catch (error) {
                console.error(`Error cleaning up ${storeName}:`, error);
            }
        }
    };
    
    const getCachedData = async (storeName, key) => {
        const memoryCache = storeName === 'pdfFiles' ? state.pdfContentCache : state.listCache;
        if (memoryCache.has(key)) return memoryCache.get(key);
        
        if (state.db) {
            return new Promise((resolve) => {
                try {
                    const transaction = state.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = (event) => {
                        const result = event.target.result;
                        if (result && result.data) {
                            memoryCache.set(key, result.data);
                            if (memoryCache.size > state.maxCacheSize) {
                                memoryCache.delete(memoryCache.keys().next().value);
                            }
                            resolve(result.data);
                        } else resolve(null);
                    };
                    request.onerror = () => resolve(null);
                } catch (error) { console.error(`Error getting ${key} from ${storeName}:`, error); resolve(null); }
            });
        }
        return null;
    };

    const storeDataInCache = async (storeName, key, data) => {
        const memoryCache = storeName === 'pdfFiles' ? state.pdfContentCache : state.listCache;
        memoryCache.set(key, data);
         if (memoryCache.size > state.maxCacheSize) {
            memoryCache.delete(memoryCache.keys().next().value);
        }

        if (state.db) {
            return new Promise((resolve) => {
                try {
                    const transaction = state.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const entry = { data: data, timestamp: Date.now(), version: state.cacheVersion };
                    entry[storeName === 'pdfFiles' ? 'url' : 'path'] = key;
                    
                    const request = store.put(entry);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => { console.error(`Error storing ${key} in ${storeName}:`, event.target.error); resolve(); };
                } catch (error) { console.error(`Error storing ${key} in ${storeName} tx:`, error); resolve(); }
            });
        }
    };

    function preloadViewerResources() {} // This function is empty, intended for future or other preload logic

    const debounce = (func, wait) => {
        let timeout;
        return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => func(...args), wait); };
    };

    async function fetchPDFFiles() {
        const cacheKey = state.pdfPath;
        let files = await getCachedData('pdfLists', cacheKey);

        if (files) {
            state.pdfFiles = files;
            renderPDFs();
            preloadNextPDFs(3);
            return;
        }

        try {
            const response = await fetch(`/api/directories?path=${encodeURIComponent(state.pdfPath)}`, { headers: { 'Cache-Control': 'max-age=3600' }});
            if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
            files = await response.json();
            
            state.pdfFiles = files
                .filter(file => file.toLowerCase().endsWith('.pdf'))
                .map(file => ({ date: file.replace('.pdf', ''), link: `/static/pyqs/${state.pdfPath}/${file}` }))
                .sort((a, b) => b.date.localeCompare(a.date));

            await storeDataInCache('pdfLists', cacheKey, state.pdfFiles);
            if (!state.pdfFiles.length) {
                DOM.pdfContainer.innerHTML = '<div class="no-pdf-message">No PDFs found for this subject.</div>';
                return;
            }
            renderPDFs();
            preloadNextPDFs(3);
        } catch (error) {
            console.error('Error fetching PDF files:', error);
            DOM.pdfContainer.innerHTML = `<div class="no-pdf-message">Error loading PDFs: ${error.message}</div>`;
        }
    }

    async function preloadNextPDFs(count) {
        const examType = DOM.examType.value;
        const filteredData = filterPDFs(examType);
        state.prefetchQueue = [];
        for (let i = 0; i < Math.min(count, filteredData.length); i++) {
            if (!await getCachedData('pdfFiles', filteredData[i].link)) {
                state.prefetchQueue.push(filteredData[i].link);
            }
        }
        processPrefetchQueue();
    }

    async function processPrefetchQueue() {
        const CONCURRENCY_LIMIT = 2;
        let activeFetches = 0;
        
        while (state.prefetchQueue.length > 0 && activeFetches < CONCURRENCY_LIMIT) {
            const pdfUrl = state.prefetchQueue.shift();
            if (!pdfUrl) continue;

            activeFetches++;
            fetch(pdfUrl, { priority: 'low', cache: 'force-cache', headers: { 'Cache-Control': 'max-age=604800' }})
                .then(response => {
                    if (!response.ok) throw new Error(`Failed to prefetch ${pdfUrl}`);
                    return response.blob();
                })
                .then(blob => storeDataInCache('pdfFiles', pdfUrl, blob))
                .catch(error => console.error(`Prefetch failed for ${pdfUrl}:`, error))
                .finally(() => {
                    activeFetches--;
                    if (state.prefetchQueue.length > 0) processPrefetchQueue();
                });
        }
    }

    function updateSubjectDisplay() {
        if (state.pdfPath) {
            const decodedPath = decodeURIComponent(state.pdfPath);
            const pathParts = decodedPath.split('/');
            const subjectName = pathParts.pop() || "Subject";
            DOM.subjectDisplay.textContent = subjectName;
            document.title = `SPPU ${subjectName} Question Papers`;
        } else {
            DOM.subjectDisplay.textContent = 'No Subject Selected';
            document.title = 'SPPU Question Paper Viewer';
        }
    }

    const filterPDFs = ((cache = new Map(), maxSize = 5) => {
        return (examType) => {
            const key = examType.toLowerCase();
            if (cache.has(key)) { const val = cache.get(key); cache.delete(key); cache.set(key, val); return val; }
            const result = state.pdfFiles.filter(file => file.date.toLowerCase().includes(key));
            if (cache.size >= maxSize) cache.delete(cache.keys().next().value);
            cache.set(key, result);
            return result;
        };
    })();

    async function loadPdfIntoIframe(iframe, pdfUrl, loader) {
        const oldObjectURL = state.activeObjectURLs.get(iframe);
        if (oldObjectURL) {
            URL.revokeObjectURL(oldObjectURL);
            state.activeObjectURLs.delete(iframe);
        }

        let fileUrlToLoad;
        const cachedPDFBlob = await getCachedData('pdfFiles', pdfUrl);

        if (cachedPDFBlob) {
            fileUrlToLoad = URL.createObjectURL(cachedPDFBlob);
        } else {
            try {
                const response = await fetch(pdfUrl);
                if (!response.ok) throw new Error(`Failed to fetch ${pdfUrl}`);
                const blob = await response.blob();
                await storeDataInCache('pdfFiles', pdfUrl, blob);
                fileUrlToLoad = URL.createObjectURL(blob);
            } catch (error) {
                console.error(`Error fetching/caching ${pdfUrl}:`, error);
                fileUrlToLoad = pdfUrl; // Fallback to direct URL if blob creation fails
            }
        }
        
        if (fileUrlToLoad.startsWith('blob:')) {
            state.activeObjectURLs.set(iframe, fileUrlToLoad);
        }
        
        iframe.src = `${state.pdfViewerBase}?file=${encodeURIComponent(fileUrlToLoad)}`;
        iframe.onload = () => { if(loader && loader.parentNode) loader.remove(); };
        iframe.onerror = () => {
            if(loader && loader.parentNode) loader.remove();
            iframe.parentElement.innerHTML = '<div class="no-pdf-message">Error loading PDF.</div>';
        };
    }

    async function renderPDFs() {
        if (state.isRendering) return;
        state.isRendering = true;

        await state.renderQueue;
        state.renderQueue = new Promise(async (resolve) => {
            const count = parseInt(DOM.pdfCount.value, 10);
            const examType = DOM.examType.value;
            const filteredData = filterPDFs(examType);

            DOM.pdfContainer.querySelectorAll('iframe').forEach(iframe => {
                const oldObjectURL = state.activeObjectURLs.get(iframe);
                if (oldObjectURL) {
                    URL.revokeObjectURL(oldObjectURL);
                    state.activeObjectURLs.delete(iframe);
                }
            });

            DOM.pdfContainer.className = `grid-${count}`;
            DOM.pdfContainer.innerHTML = filteredData.length ? '' : '<div class="no-pdf-message">No papers available for this exam type.</div>';

            if (!filteredData.length) { state.isRendering = false; resolve(); return; }

            const fragment = document.createDocumentFragment();
            const maxRender = Math.min(count, filteredData.length);

            for (let i = 0; i < count; i++) {
                const div = document.createElement('div');
                div.className = 'pdf-viewer';
                if (i < maxRender) {
                    const loader = document.createElement('div');
                    loader.className = 'loader-container';
                    loader.innerHTML = '<div class="loader"></div>';
                    div.appendChild(loader);
                    
                    const selector = createPaperSelector(filteredData, i, `viewer-${i}`);
                    div.appendChild(selector); // Appended to pdf-viewer div
                    
                    const iframe = document.createElement('iframe');
                    // Insert iframe before selector so selector is on top, or rely on z-index
                    div.appendChild(iframe); 
                    // To ensure selector is on top, it's better to append iframe first, then selector,
                    // or adjust DOM structure if selector must be before iframe for some reason.
                    // Given current absolute positioning and z-index of selector, order here mainly affects tab order.
                    // Let's append selector after iframe to ensure it renders on top of iframe content if any overlap occurs without z-index.
                    // However, with z-index:10 for selector, this should be fine.
                    // Original order: loader, selector, iframe.
                    // Let's maintain: loader, selector, iframe. If selector covers part of iframe, it's intended.

                    loadPdfIntoIframe(iframe, filteredData[i].link, loader);
                } else {
                    div.innerHTML = '<div class="no-more-papers">No additional papers to display</div>';
                }
                fragment.appendChild(div);
            }
            DOM.pdfContainer.appendChild(fragment);
            state.isRendering = false;
            resolve();
        });
    }

    function createPaperSelector(data, initialIndex, viewerId) {
        const selectorContainer = document.createElement('div');
        selectorContainer.className = 'paper-selector';
        
        const label = document.createElement('label');
        label.className = 'paper-selector-label';
        label.textContent = 'Paper:';
        const selectId = `paper-select-${viewerId}`;
        label.htmlFor = selectId;
        
        const select = document.createElement('select');
        select.id = selectId;
        select.size = 1; 
        select.addEventListener('focus', () => { select.size = Math.min(5, data.length || 1); }); // Ensure size is at least 1
        select.addEventListener('blur', () => { select.size = 1; });
        select.addEventListener('change', () => { select.size = 1; }); // Collapse on change

        data.forEach((item, idx) => {
            const option = document.createElement('option');
            option.value = idx; 
            option.textContent = item.date;
            if (idx === initialIndex) option.selected = true;
            select.appendChild(option);
        });

        select.addEventListener('change', debounce(async (e) => {
            const idx = parseInt(e.target.value, 10);
            const pdfUrl = data[idx].link;
            const viewerDiv = selectorContainer.closest('.pdf-viewer');
            const iframe = viewerDiv.querySelector('iframe');
            if (!iframe) return;

            const loader = document.createElement('div');
            loader.className = 'loader-container';
            loader.innerHTML = '<div class="loader"></div>';
            
            // Insert loader before the iframe, if iframe is not the first child.
            // If selector is before iframe, this is fine.
            if (iframe.previousSibling && iframe.previousSibling !== selectorContainer) {
                 viewerDiv.insertBefore(loader, iframe);
            } else {
                 viewerDiv.appendChild(loader); // Fallback or if iframe is first.
            }
            // A safer way:
            // viewerDiv.appendChild(loader); // Add it, loadPdfIntoIframe will remove it.
            // This might cause momentary flicker if loader is appended at the end.
            // The original logic of appending loader as first child of viewer in renderPDFs seems fine.
            // For changes, it should be added relative to the iframe.
            viewerDiv.insertBefore(loader, iframe);


            await loadPdfIntoIframe(iframe, pdfUrl, loader);
        }, 150));

        selectorContainer.appendChild(label);
        selectorContainer.appendChild(select);
        return selectorContainer;
    }

    function toggleFullscreen() {
        if (document.fullscreenElement) document.exitFullscreen();
        else document.documentElement.requestFullscreen({ navigationUI: 'hide' });
    }

    function updateFullscreenButton() {
        DOM.fullscreenBtn.innerHTML = document.fullscreenElement ?
            `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 14h6m0 0v6m0-6l-7 7m17-11h-6m0 0V4m0 6l7-7"/></svg> Exit Fullscreen` :
            `<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg> Fullscreen`;
    }

    function setupEventListeners() {
        const debouncedRender = debounce(renderPDFs, 250);
        DOM.pdfCount.addEventListener('change', debouncedRender);
        DOM.examType.addEventListener('change', () => {
            debouncedRender();
            preloadNextPDFs(3);
        });
        DOM.fullscreenBtn.addEventListener('click', toggleFullscreen);
        DOM.backBtn.addEventListener('click', () => window.location.href = '/questionpapers');
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && document.fullscreenElement) document.exitFullscreen(); });
    }

    async function init() {
        preloadViewerResources();
        updateSubjectDisplay();
        setupEventListeners();
        await initDB();
        
        if (state.pdfPath) {
            const preloadIframe = document.createElement('iframe');
            preloadIframe.style.display = 'none';
            preloadIframe.src = state.pdfViewerBase; // Preload viewer.html
            document.body.appendChild(preloadIframe);
            // Remove after a delay to ensure it loads but doesn't linger
            setTimeout(() => preloadIframe.remove(), 5000); 
            
            fetchPDFFiles();
        } else {
            DOM.pdfContainer.innerHTML = '<div class="no-pdf-message">No PDF path specified. Please select a subject.</div>';
            DOM.subjectDisplay.textContent = 'No Subject Selected';
        }
    }
    document.addEventListener('DOMContentLoaded', init);</script>